%% single cycle cpu mode 


specification_muxers: THEORY
BEGIN

IMPORTING datapath
IMPORTING decoder_props

rs_v: VAR bvec[32]
rt_v: VAR bvec[32]
dec:  VAR decoder_signal
instr: VAR instruction

src1_mux(dec,rs_v,rt_v ): bvec[32] = 
      TABLE
       dec`sela
    %---------+---------++
    |   rs    | rs_v    ||
    %---------+---------++
    |   rt    | rt_v    ||
    %---------+---------++
      ENDTABLE

src2_mux(dec,rt_v,instr): bvec[32] =
    LET     
      shamt_v = zero_extend[5](32)( shamtbv(instr)),
      zext_v =  zero_extend[16](32) (short_immed_of (instr)),
      sext_v =  sign_extend[16](32) (short_immed_of (instr))  
    IN TABLE
     dec`selb
     %--------%----------++
     |  rt    |  rt_v    ||
     |  shamt |  shamt_v ||
     |  zext  |  zext_v  ||
     |  sext  |  sext_v  ||
     %--------%----------++
     ENDTABLE
 
dst_addr_mux(dec, instr): bvec[5] = 
     TABLE
     dec`seld
     %--------+-----------++
     | rd     | rd(instr) ||
     | rt     | rt(instr) ||
     | ra     | ra_reg    ||
     %--------+-----------++
     ENDTABLE

wb_val_mux(dec:decoder_signal, alu_out:bvec[32], 
           pc_4:bvec[32], loadv:bvec[32], instr): bvec[32] =
     LET upper_imm =  zero_extend_lsend[16](32) (short_immed_of(instr))
     IN TABLE
         dec`wbsrc
          %--------+----------------++
          | aluout | alu_out        ||
          | lui    | upper_imm      ||
          | load   | loadv         ||
          | pc4    | pc_4           ||
          %--------+----------------++          
         ENDTABLE
 

END specification_muxers


specification_trans: THEORY
BEGIN

IMPORTING datapath
%IMPORTING instruction_decoder
IMPORTING decoder_props
IMPORTING specification_state
IMPORTING specification_muxers

a: VAR state_A


spt_ifu(a): ifu = (# pc := a`pc, imem := a`imem #)

spt_instr(a): instruction = ifu_get_output(spt_ifu(a))`ins

spt_invalid_pc(a): bool = NOT ifu_get_output(spt_ifu(a))`addr_valid?

spt_dec(a): decoder_signal = decoder( get_abs_opcode ( spt_instr (a )) )

spt_rf_input_read(a): rf_input_read = (# addr_1 := rs( spt_instr (a)), addr_2 := rt ( spt_instr(a)) #)

spt_rs(a): bvec[32] = rf_get_output( spt_rf_input_read(a), a`rf )`val_1

spt_rt(a): bvec[32] = rf_get_output( spt_rf_input_read(a), a`rf )`val_2

spt_pc4(a): bvec[32] = a`pc + 4

spt_src1(a): bvec[32] = src1_mux( spt_dec(a), spt_rs(a), spt_rt(a) )

spt_src2(a): bvec[32] = src2_mux( spt_dec(a), spt_rt(a), spt_instr(a) )

spt_sext(a): bvec[32] = sign_extend[16](32) (short_immed_of ( spt_instr(a)) ) 

spt_branch_pc(a): bvec[32] = spt_pc4(a) + spt_sext(a)

spt_jmp_pc(a): bvec[32] = spt_pc4(a)^(31,28) o long_immed_of( spt_instr(a) ) o b00

spt_aluout(a): alu_out = alu( spt_src1(a), spt_src2(a) , spt_dec(a)`aluop )

spt_exception_overflow?(a): bool = NOT spt_invalid_pc(a) AND spt_dec(a)`checkov? AND spt_aluout(a)`ov

spt_exception_dmem?(a): bool = NOT spt_invalid_pc(a) AND ( spt_dec(a)`load? OR spt_dec(a)`store? ) AND NOT dmem_addr_valid?( spt_aluout(a)`out )

spt_exception_instr?(a): bool = spt_dec(a)`invalid?

spt_dmem_wen(a): bool = spt_dec(a)`store? AND NOT spt_exception_dmem?(a) AND ( spt_dec(a)`atom? IMPLIES a`llflag )

spt_dmem_input_read(a): dmem_input_read = LET dec = spt_dec(a) IN (# addr := spt_aluout(a)`out, mwidth := dec`mwidth, se := dec`loadse? #)

spt_dmem_input_write(a): dmem_input_write = LET dec = spt_dec(a) IN
               (# addr := spt_aluout(a)`out, mwidth := dec`mwidth, 
                  wen := spt_dmem_wen(a), value := spt_rt(a) #)

spt_dmem_val(a): bvec[32] = dmem_get_output( spt_dmem_input_read(a), a`dmem )

spt_next_dmem(a): data_memory = dmem_update( spt_dmem_input_write(a), a`dmem )

spt_rf_wb_val(a): bvec[32] = wb_val_mux(spt_dec(a), spt_aluout(a)`out, spt_pc4(a), spt_dmem_val(a), spt_instr(a))

spt_rf_wen(a): bool = LET dec = spt_dec(a) IN NOT spt_invalid_pc(a) AND dec`wb? AND NOT spt_exception_overflow?(a) AND NOT spt_exception_dmem?(a)

spt_rf_dst(a): bvec[5] = dst_addr_mux( spt_dec(a), spt_instr(a) )

spt_next_rf(a): regfile = rf_update( (# en := spt_rf_wen(a), addr := spt_rf_dst(a), value := spt_rf_wb_val(a) #), a`rf )

spt_exception(a): bool = spt_invalid_pc(a) OR spt_exception_instr?(a) OR spt_exception_overflow?(a) OR spt_exception_dmem?(a)

spt_eq(a): bool = spt_rs(a) = spt_rt(a)

spt_npc(a): bvec[32] =  LET dec = spt_dec(a) IN
     IF spt_exception(a) THEN exception_entry ELSE    
     TABLE
     | dec`beq? AND spt_eq(a)     |  spt_branch_pc(a) ||
     | dec`bne? AND NOT spt_eq(a) |  spt_branch_pc(a) ||
     | dec`jmp?                   |  spt_jmp_pc(a)    ||
     | dec`jr?                    |  spt_rs(a)        ||
     | ELSE                       |  zero             ||
     ENDTABLE
     ENDIF
spt_npc_valid(a): bool = LET dec = spt_dec(a) IN
  ( NOT spt_invalid_pc(a) AND ( (dec`beq? AND spt_eq(a)) OR (dec`bne? AND NOT spt_eq(a)) OR dec`jmp? OR dec`jr? )) 
  OR spt_exception(a)



A_step(a: state_A): state_A = 
  LET ifu = (# pc := a`pc, imem := a`imem #),
      ifu_out = ifu_get_output(ifu),
      valid_pc = ifu_out`addr_valid? ,
      instr = ifu_out`ins,
      % ifu 信号
      op = get_abs_opcode(instr),
      dec = decoder(op),
      % 译码器信号
      rf_read_signal = (# addr_1 := rs(instr), addr_2 := rt(instr) #),
      rf_read_val = rf_get_output( rf_read_signal, a`rf ),
      rs_val = rf_read_val`val_1,
      rt_val = rf_read_val`val_2,
      % rf 读
      pc_4 = ifu`pc + 4,
      % pc + 4
      sext_v =  sign_extend[16](32) (short_immed_of (instr)),  
      % 立即数扩展
      src1 = src1_mux(dec, rs_val, rt_val),
      src2 = src2_mux(dec, rt_val, instr),
      % 源操作数 mux
      rs_eq_rt = rs_val = rt_val,
      % 比较器
      branch_pc = pc_4 + sext_v,
      % 短跳pc目标
      jmp_pc = pc_4^(31,28) o long_immed_of(instr) o b00,
      % 长跳pc目标
      alu_out = alu(src1, src2,dec`aluop),
      alu_out_bv = alu_out`out,
      alu_out_ov = alu_out`ov,
      % ALU计算
      exception_ov = dec`checkov? AND alu_out_ov,
      exception_dmem_addr = ( dec`load? OR dec`store? ) AND NOT dmem_addr_valid?(alu_out_bv),
      exception_instr = dec`invalid?,
      % 异常
      dmem_wen = valid_pc AND dec`store? AND (dec`atom? IMPLIES a`llflag ) AND NOT exception_dmem_addr,
      dmem_input_r = (# addr := alu_out_bv, mwidth := dec`mwidth, se := dec`loadse? #),
      dmem_input_w = (# addr := alu_out_bv, mwidth := dec`mwidth, value:= rt_val,  wen := dmem_wen #),      
      dmem_read_v = dmem_get_output( dmem_input_r, a`dmem ), 
      next_dmem = dmem_update(dmem_input_w, a`dmem),
      % dmem读、写      
      wbval =  wb_val_mux(dec, alu_out_bv, pc_4, dmem_read_v, instr),
      dst = dst_addr_mux(dec, instr),
      rf_write = (# addr := dst, value := wbval, en:= valid_pc AND dec`wb? AND NOT exception_ov AND NOT exception_dmem_addr #),  
      next_rf = rf_update(rf_write, a`rf),
      % rf 写
      exception = NOT valid_pc OR exception_instr OR exception_ov OR exception_dmem_addr,
      npc = IF exception THEN exception_entry ELSE    
     TABLE
     | dec`beq? AND rs_eq_rt     |  branch_pc ||
     | dec`bne? AND NOT rs_eq_rt |  branch_pc ||
     | dec`jmp?                  |  jmp_pc    ||
     | dec`jr?                   |  rs_val    ||
     | ELSE                      |  zero      ||
     ENDTABLE
     ENDIF,
      npc_valid = ( valid_pc AND ( (dec`beq? AND rs_eq_rt) OR (dec`bne? AND NOT rs_eq_rt) OR dec`jmp? OR dec`jr? )) OR exception,
      ifu_input = (# npc := npc, npc_valid? := npc_valid #),
      next_ifu = ifu_update( ifu_input, ifu ), 
      next_pc = next_ifu`pc,
      next_imem = next_ifu`imem,
      next_epc = IF exception THEN a`pc ELSE a`epc ENDIF,
      next_llflag = IF exception THEN FALSE ELSE
      TABLE  
      %-------------------------+-----------%%
      | dec`atom? AND dec`load? | TRUE      ||
      | dec`atom? AND dec`store?| FALSE     ||
      | ELSE                    | llflag(a) ||
      %-------------------------+-----------%%
      ENDTABLE
      ENDIF
  IN 
  (# pc := next_pc,
     rf := next_rf,
     dmem := next_dmem,
     imem := next_imem,
     epc  := next_epc,
     llflag := next_llflag
   #)  


i: VAR below(2)
A_step_new(a,i) : state_A = IF i=0 THEN a ELSE A_step(a) ENDIF


END specification_trans



specification_trans_props : THEORY
BEGIN

IMPORTING specification_trans

a: VAR state_A

instr(a) : instruction =
	IF imem_addr_pred(pc(a)) THEN imem(a)(pc(a)) ELSE zero ENDIF


rs(a): bvec[32] = select_r(rf(a), rs(instr(a)))
rt(a): bvec[32] = select_r(rf(a), rt(instr(a)))

mem_addr_calcu(a): bvec[32] = LET ins = instr(a) IN rs(a) + sign_extend[16](32)(short_immed_of(ins))

action_exception(a) : bool = A_step(a) = a WITH [ pc := exception_entry, epc := a`pc, llflag := FALSE] 

%|- *_prop :PROOF
%|- (then (skosimp*)
%|-  (auto-rewrite! concat_bottom) (auto-rewrite! zero_extend) (auto-rewrite! shamt) 
%|-  (auto-rewrite-theory specification_trans_props :always? T) (assert)
%|-  (apply (then (decompose-equality +) 
%|-  (auto-rewrite-theory specification_trans :always? T) 
%|-  (auto-rewrite-theory specification_muxers :always? T)
%|-  (assert)
%|-  (auto-rewrite-theory datapath :always? T)
%|-  (auto-rewrite-theory instruction_decoder :always? T)
%|-  (assert))))
%|- QED


% case: pc exception
exceptionpc_prop:     THEOREM NOT imem_addr_pred(a`pc) IMPLIES action_exception(a)

% case: instr exception
exceptioninstr_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = invalid IMPLIES action_exception(a)

% case: instr = add and not overflow
add_nooverflow_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = add AND NOT overflow(rs(a) , rt(a) ) 
     IMPLIES A_step(a) = a WITH [ pc := a`pc + 4, rf := assign_r(a`rf, rd(instr(a)), rs(a) + rt(a)) ]

% case: instr = add and overflow
add_overflow_prop:   THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = add AND overflow(rs(a), rt(a)) IMPLIES action_exception(a)


% case instr = addu
addu_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = addu IMPLIES 
     A_step(a) = a WITH [ pc := a`pc + 4, rf := assign_r(a`rf, rd(instr(a)), rs(a) + rt(a)) ]

% case: srl:
srl_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = srl IMPLIES
     A_step(a) = a WITH [ pc := a`pc + 4, rf := assign_r(a`rf, rd(instr(a)), right_shift(shamt(instr(a)), rt(a))) ]


% case: sll:
sll_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = sll IMPLIES
     A_step(a) = a WITH [ pc := a`pc + 4, rf := assign_r(a`rf, rd(instr(a)), left_shift(shamt(instr(a)), rt(a))) ]



% case instr = lw AND exception

lw_exception_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = lw AND NOT dmem_addr_valid?( mem_addr_calcu(a) ) IMPLIES action_exception(a)

lw_noexception_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = lw AND dmem_addr_valid?(mem_addr_calcu(a)) IMPLIES
      A_step(a) = a WITH [ pc := a`pc + 4, rf := assign_r(a`rf, rt(instr(a)), read32(a`dmem, mem_addr_calcu(a))) ]

% case instr = sb
sb_exception_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = sb AND NOT dmem_addr_valid?( mem_addr_calcu(a) ) IMPLIES action_exception(a)

sb_noexcption_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = sb AND dmem_addr_valid?( mem_addr_calcu(a) ) IMPLIES 
     A_step(a) =  a WITH [ pc := a`pc + 4, dmem := write8(a`dmem, mem_addr_calcu(a), rt(a)^(7,0) ) ]


% beq
beq_jmp_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = beq AND rs(a) = rt(a) IMPLIES 
     A_step(a) = a WITH [ pc := a`pc + 4 + sign_extend[16](32)(short_immed_of(instr(a))) ]

beq_nojmp_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = beq AND rs(a) /= rt(a) IMPLIES 
     A_step(a) = a WITH [ pc := a`pc + 4 ]

%|- bne_jmp_prop: PROOF
%|- beq_nojmp_prop : PROOF
%|- (then (skosimp*) (auto-rewrite! concat_bottom)
%|-  (auto-rewrite! zero_extend) (auto-rewrite! shamt)
%|-  (auto-rewrite-theory specification_trans_props :always? T) (assert)
%|-  (apply (then (decompose-equality 2)
%|-          (auto-rewrite-theory specification_trans :always? T)
%|-          (auto-rewrite-theory specification_muxers :always? T) (assert)
%|-          (auto-rewrite-theory datapath :always? T)
%|-          (auto-rewrite-theory instruction_decoder :always? T)
%|-          (assert))))
%|- QED

% bne
bne_jmp_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = bne AND rs(a) /= rt(a) IMPLIES 
     A_step(a) = a WITH [ pc := a`pc + 4 + sign_extend[16](32)(short_immed_of(instr(a))) ]


bne_nojmp_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = bne AND rs(a) = rt(a) IMPLIES 
     A_step(a) = a WITH [ pc := a`pc + 4 ]


% lui
lui_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = lui IMPLIES 
     A_step(a) = a WITH [ pc := a`pc + 4, rf := assign_r(a`rf, rt(instr(a)), zero_extend_lsend[16](32)(short_immed_of(instr(a)))) ]


% j
j_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = j IMPLIES 
     A_step(a) = a WITH [ pc := (a`pc + 4) ^ (31, 28) o long_immed_of(instr(a)) o b00  ]

% jal
jal_prop: THEOREM imem_addr_pred(a`pc) AND get_abs_opcode(instr(a)) = jal IMPLIES 
     A_step(a) = a WITH [
      pc := (a`pc + 4) ^ (31, 28) o long_immed_of(instr(a)) o b00,
      rf := assign_r(rf(a), ra_reg, pc(a) + 4 )
       ]



END specification_trans_props


specification_trans_props_2 : THEORY
BEGIN

IMPORTING specification_trans
IMPORTING specification


%|- *_prop_* :PROOF
%|- (then (skosimp*) 
%|-  (auto-rewrite-theory specification :always? T)
%|-  (assert)
%|-  (skosimp*)
%|-  (assert)
%|-  (rewrite -1)
%|-  (auto-rewrite-theory specification_trans :always? T) 
%|-  (auto-rewrite-theory datapath :always? T)
%|-  (auto-rewrite-theory instruction_decoder :always? T)
%|-  (assert) 
%|-  (apply (then (split-abs-opcode)  
%|-     (auto-rewrite! concat_bottom) (auto-rewrite! zero_extend) (auto-rewrite! shamt))))
%|- QED


spec_trans_prop_0: THEOREM specification.A_step = specification_trans.A_step IMPLIES spec_0_goal

spec_trans_prop_1: THEOREM specification.A_step = specification_trans.A_step IMPLIES spec_1_goal 




END specification_trans_props_2
