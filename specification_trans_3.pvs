datapath: THEORY
BEGIN

IMPORTING abstract_instructions

% alu
alu_op : TYPE = { add, sub, and, or, xor, sll, srl, slt, sltu, inv}
alu_out: TYPE = [# out: bvec[32], 
                   ov:  bool  % 溢出？
                #]

alu(a:bvec[32], b:bvec[32], op:alu_op) : alu_out =
       (# 
          out := 
         TABLE
           op
         %-------+--------------------------------++  
         | add   | a + b                          ||
         | sub   | a - b                          ||
         | and   | a and b                        ||
         | or    | a or  b                        ||
         | xor   | a xor b                        ||
         | sll   | left_shift(bv2nat(b^(4,0)),a)  ||
         | srl   | right_shift(bv2nat(b^(4,0)),a) ||
         | slt   | alu_slt(a,b)                   ||
         | sltu  | alu_sltu(a,b)                  ||
         | inv   | a - b                          ||
         %-------+--------------------------------++
         ENDTABLE,
          ov :=
         TABLE
           op
         %-----+------------------------------------------++  
         | add | overflow(a,b)                            ||
         | sub | bv2int(b)=minint[32] XOR overflow(a,-b)  ||
         | ELSE| FALSE                                    ||
         %-----+------------------------------------------++         
         ENDTABLE
        #)

END datapath


instruction_decoder: THEORY
BEGIN
%  指令译码

% 指令分类
IMPORTING datapath
load?(op:abs_opcode): bool =  op=lb OR op=lbu OR op=lh OR op=lhu OR op=lw OR op=ll  
store?(op:abs_opcode): bool = op=sb OR op=sh  OR op=sw OR op=sc

mem_access?(op:abs_opcode): bool = load?(op) OR store?(op)

alu_r?(op:abs_opcode): bool = add?(op) OR sub?(op) OR addu?(op) OR sub?(op) OR subu?(op) OR op=and OR op=or OR op=nor OR slt?(op) OR sltu?(op)        
alu_shift?(op:abs_opcode): bool= sll?(op) OR srl?(op)
alu_imm_logic?(op:abs_opcode): bool = andi?(op) OR ori?(op)
alu_imm_cmp?(op:abs_opcode): bool = slti?(op) OR sltiu?(op)
alu_imm_other?(op:abs_opcode): bool = addi?(op) OR addiu?(op) 
alu_imm?(op:abs_opcode): bool = alu_imm_logic?(op) OR alu_imm_cmp?(op) OR  alu_imm_other?(op)
need_wb?(op:abs_opcode): bool = alu_r?(op) OR alu_imm?(op) OR alu_shift?(op) OR lui?(op) OR load?(op) OR jal?(op)

need_alu?(op:abs_opcode): bool = alu_r?(op) OR alu_shift?(op) OR alu_imm?(op) OR mem_access?(op)

branch?(op:abs_opcode): bool=beq?(op) OR bne?(op)

jmp?(op:abs_opcode): bool=j?(op) OR jr?(op) OR jal?(op)


%  alu控制信号
get_alu_op(op: abs_opcode): alu_op = 
         TABLE
         %----------------------------------------------------+---------%%  
         | add?(op) OR addu?(op) OR addi?(op) OR addiu?(op)   | add     ||
         | sub?(op) OR subu?(op)                              | sub     ||
         | op=and   OR andi?(op)                              | and     ||
         | op=or OR ori?(op)                                  | or      ||
         | nor?(op)                                           | xor     ||
         | srl?(op)                                           | srl     ||
         | slt?(op) OR slti?(op)                              | slt     ||
         | sltu?(op) OR sltiu?(op)                            | sltu    ||
         | sll?(op)                                           | sll     ||
         | mem_access?(op)                                    | add     ||
         | ELSE                                               | inv     ||
         %----------------------------------------------------+---------%%
         ENDTABLE


% 端口选择
sel_a : TYPE = {rs, rt} 
sel_b : TYPE = {rt, shamt, zext, sext}
sel_dest: TYPE = {rd, rt, ra}

get_sel_a(op: abs_opcode): sel_a =
      TABLE
      %----------------+-----------++
      | alu_r?(op)     |     rs    ||
      | alu_shift?(op) |     rt    ||
      | alu_imm?(op)   |     rs    ||
      | mem_access?(op)|     rs    ||
      | ELSE           |     rs    ||
      %----------------+-----------++
      ENDTABLE 

get_sel_b(op: abs_opcode):  sel_b =
      TABLE
      %--------------------+-------++
      | alu_r?(op)         | rt    ||
      | alu_shift?(op)     | shamt ||
      | alu_imm_other?(op) | sext  ||
      | alu_imm_logic?(op) | zext  ||
      | sltiu?(op)         | zext  ||
      | slti?(op)          | sext  ||
      | mem_access?(op)    | sext  ||
      | ELSE               | zext  ||
      %--------------------+-------++
      ENDTABLE

get_sel_dest(op: abs_opcode): sel_dest =
      TABLE
      %---------------------+--------++
      | alu_r?(op)          |  rd    ||
      | alu_shift?(op)      |  rd    ||
      | alu_imm?(op)        |  rt    ||
      | load?(op)           |  rt    ||
      | lui?(op)            |  rt    ||
      | jal?(op)            |  ra    ||
      | ELSE                |  rd    ||
      %---------------------+--------++
      ENDTABLE      

% 写回值选择
wb_src: TYPE = {aluout, load, pc4, lui}

get_wb_src(op: abs_opcode): wb_src =
     TABLE
     %---------------------+--------++
     |  alu_r?(op)         | aluout ||
     |  alu_shift?(op)     | aluout ||
     |  alu_imm?(op)       | aluout ||
     |  jal?(op)           | pc4    ||
     |  lui?(op)           | lui    ||
     |  load?(op)          | load   ||
     |  ELSE               | pc4    ||
     %---------------------+--------++
     ENDTABLE

mem_access_width : TYPE = {w8,w16,w32}

get_mem_access_width(op:abs_opcode)  : mem_access_width =
     TABLE
     %------------------------------------------+-------++
     | lb?(op) OR lbu?(op) OR sb?(op)           | w8    ||
     | lh?(op) OR lhu?(op) OR sh?(op)           | w16   ||
     | lw?(op) OR ll?(op) OR sw?(op) OR sc?(op) | w32   ||
     | ELSE                                     | w32   ||
     %------------------------------------------+-------++
     ENDTABLE

get_load_se(op:abs_opcode): bool = lb?(op) OR lh?(op) 

get_check_overflow(op:abs_opcode): bool = add?(op) OR sub?(op) OR addi?(op)

decoder_signal : TYPE = [# aluop: alu_op,
                           sela:  sel_a,
                           selb:  sel_b,
                           seld:  sel_dest,
                           wb?  : bool,
                           wbsrc: wb_src,
                           load?:  bool,
                           loadse?: bool,
                           store?: bool,
                           mwidth:  mem_access_width,
                           checkov?: bool,
                           beq?: bool,
                           bne?: bool,
                           jmp?: bool,
                           jr?: bool,
                           lui?: bool,
                           invalid?: bool,
                           atom?: bool
                           #]

decoder(op:abs_opcode) : decoder_signal = (#
                            aluop := get_alu_op(op),
                            sela  := get_sel_a(op),
                            selb  := get_sel_b(op),
                            seld  := get_sel_dest(op),
                            wb?   := need_wb?(op),
                            wbsrc := get_wb_src(op),
                            load?  := load?(op),
                            loadse? := get_load_se(op),
                            store? := store?(op),
                            mwidth := get_mem_access_width(op),
                            checkov? := get_check_overflow(op),
                            beq?  := beq?(op),
                            bne?  := bne?(op),
                            jmp?  := j?(op) OR jal?(op),
                            jr?   := jr?(op),
                            lui?  := lui?(op),
                            invalid? := invalid?(op),
                            atom? := sc?(op) OR ll?(op)
                            #)

END instruction_decoder


decoder_props: THEORY
BEGIN
IMPORTING instruction_decoder

op: VAR abs_opcode

decoder_load: LEMMA load?(decoder(op)`wbsrc) = decoder(op)`load?
decoder_atom: LEMMA decoder(op)`atom? IMPLIES decoder(op)`mwidth = w32
decoder_atom_2: LEMMA decoder(op)`atom? IMPLIES decoder(op)`load? OR decoder(op)`store?

decoder_store_sela: LEMMA decoder(op)`store? IMPLIES decoder(op)`sela = rs
decoder_store_selb: LEMMA decoder(op)`store? IMPLIES decoder(op)`selb = sext

%|- decoder_store_sela : PROOF
%|- decoder_store_selb : PROOF
%|- (then (skosimp) (auto-rewrite-theory instruction_decoder :always? T)
%|-  (assert) (case-analysis))
%|- QED


%|- decoder_disjoint_* :PROOF
%|- (then (skosimp) (flatten) (auto-rewrite-theory instruction_decoder) (case-analysis) (bddsimp))
%|- QED

decoder_disjoint_1: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`load?
decoder_disjoint_2: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`store?
decoder_disjoint_3: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`beq?
decoder_disjoint_4: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`bne?
decoder_disjoint_5: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`checkov?
decoder_disjoint_6: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`jmp?
decoder_disjoint_7: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`jr?
decoder_disjoint_8: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`lui?
decoder_disjoint_9: LEMMA decoder(op)`invalid? IMPLIES NOT decoder(op)`wb?


decoder_disjoint_12: LEMMA decoder(op)`load? IMPLIES NOT decoder(op)`store?
decoder_disjoint_13: LEMMA decoder(op)`load? IMPLIES NOT decoder(op)`beq?
decoder_disjoint_14: LEMMA decoder(op)`load? IMPLIES NOT decoder(op)`bne?
decoder_disjoint_15: LEMMA decoder(op)`load? IMPLIES NOT decoder(op)`checkov?
decoder_disjoint_16: LEMMA decoder(op)`load? IMPLIES NOT decoder(op)`jmp?
decoder_disjoint_17: LEMMA decoder(op)`load? IMPLIES NOT decoder(op)`jr?
decoder_disjoint_18: LEMMA decoder(op)`load? IMPLIES NOT decoder(op)`lui?
decoder_disjoint_19: LEMMA  decoder(op)`load? IMPLIES decoder(op)`wb?

decoder_disjoint_23: LEMMA decoder(op)`store? IMPLIES NOT decoder(op)`beq?
decoder_disjoint_24: LEMMA decoder(op)`store? IMPLIES NOT decoder(op)`bne?
decoder_disjoint_25: LEMMA decoder(op)`store? IMPLIES NOT decoder(op)`checkov?
decoder_disjoint_26: LEMMA decoder(op)`store? IMPLIES NOT decoder(op)`jmp?
decoder_disjoint_27: LEMMA decoder(op)`store? IMPLIES NOT decoder(op)`jr?
decoder_disjoint_28: LEMMA decoder(op)`store? IMPLIES NOT decoder(op)`lui?
decoder_disjoint_29: LEMMA decoder(op)`store? IMPLIES NOT decoder(op)`wb?

decoder_disjoint_34: LEMMA decoder(op)`beq? IMPLIES NOT decoder(op)`bne?
decoder_disjoint_35: LEMMA decoder(op)`beq? IMPLIES NOT decoder(op)`checkov?
decoder_disjoint_36: LEMMA decoder(op)`beq? IMPLIES NOT decoder(op)`jmp?
decoder_disjoint_37: LEMMA decoder(op)`beq? IMPLIES NOT decoder(op)`jr?
decoder_disjoint_38: LEMMA decoder(op)`beq? IMPLIES NOT decoder(op)`lui?
decoder_disjoint_39: LEMMA decoder(op)`beq? IMPLIES NOT decoder(op)`wb?


decoder_disjoint_45: LEMMA decoder(op)`bne? IMPLIES NOT decoder(op)`checkov?
decoder_disjoint_46: LEMMA decoder(op)`bne? IMPLIES NOT decoder(op)`jmp?
decoder_disjoint_47: LEMMA decoder(op)`bne? IMPLIES NOT decoder(op)`jr?
decoder_disjoint_48: LEMMA decoder(op)`bne? IMPLIES NOT decoder(op)`lui?
decoder_disjoint_49: LEMMA decoder(op)`bne? IMPLIES NOT decoder(op)`wb?

decoder_disjoint_56: LEMMA decoder(op)`checkov? IMPLIES NOT decoder(op)`jmp?
decoder_disjoint_57: LEMMA decoder(op)`checkov? IMPLIES NOT decoder(op)`jr?
decoder_disjoint_58: LEMMA decoder(op)`checkov? IMPLIES NOT decoder(op)`lui?
decoder_disjoint_59: LEMMA decoder(op)`checkov? IMPLIES decoder(op)`wb?

decoder_disjoint_67: LEMMA decoder(op)`jmp? IMPLIES NOT decoder(op)`jr?
decoder_disjoint_68: LEMMA decoder(op)`jmp? IMPLIES NOT decoder(op)`lui?

decoder_disjoint_78: LEMMA decoder(op)`jr? IMPLIES NOT decoder(op)`lui?
decoder_disjoint_79: LEMMA decoder(op)`jr? IMPLIES NOT decoder(op)`wb?



END decoder_props


specification_trans_3: THEORY
BEGIN

IMPORTING specification_trans_2
IMPORTING instruction_decoder

valid_pc_state_A: TYPE  = { a:state_A | imem_addr_pred(pc(a)) } 

a: VAR valid_pc_state_A

op(a):   abs_opcode = get_abs_opcode(instr(a))

decoder(a): decoder_signal = decoder(op(a))

src1(a): bvec[32] =
          TABLE
           decoder(a)`sela
           %--------%---------++
           |  rs    |  rs(a)  ||
           |  rt    |  rt(a)  ||
           %--------%---------++
          ENDTABLE

src2(a): bvec[32] =
          LET ins=instr(a) IN 
          TABLE
          decoder(a)`selb
           |  rt    |  rt(a)                                   ||
           |  shamt |  zero_extend[5](32)(shamtbv(ins))        ||
           |  zext  |  zero_extend[16](32)(short_immed_of(ins))||
           |  sext  |  sign_extend[16](32)(short_immed_of(ins))||
          ENDTABLE

rs_eq_rt(a): bool = rs(a) = rt(a)

dst(a): reg_addr =
           LET ins=instr(a) IN 
           TABLE
           decoder(a)`seld
           %--------+---------++
           | rd     | rd(ins) ||
           | rt     | rt(ins) ||
           | ra     | ra_reg  ||
           %--------+---------++
           ENDTABLE

alu_out(a): alu_out = alu(src1(a),src2(a), decoder(a)`aluop) 

mem_addr_arch: LEMMA  mem_access?(op(a)) IMPLIES  mem_addr_calcu(a) = alu_out(a)`out  

%|- mem_addr_arch : PROOF
%|- (then (skosimp) (auto-rewrite-theory datapath)
%|-  (auto-rewrite-theory instruction_decoder)
%|-  (auto-rewrite-theory specification_trans_3) (expand mem_addr_calcu)
%|-  (assert) (split-abs-opcode))
%|- QED

exception?(a): bool = 
    LET
        mem_addr_valid_condition = dmem_addr_valid?(alu_out(a)`out)
    IN 
    TABLE
      %--------------------------------------+-----------------------------------%%
      | decoder(a)`checkov?                  | alu_out(a)`ov                     ||
      | decoder(a)`load? OR decoder(a)`store?| NOT mem_addr_valid_condition      ||
      | decoder(a)`invalid?                  | TRUE                              ||
      | ELSE                                 | FALSE                             ||
      %--------------------------------------+-----------------------------------%%
    ENDTABLE



exception_arch: LEMMA   exception?(instr(a))(a) = exception?(a) 

%|- exception_arch : PROOF
%|- (then (skosimp) (auto-rewrite-theory instruction_decoder)
%|-  (auto-rewrite-theory datapath)
%|-  (auto-rewrite-theory specification_trans_3) (expand exception?)
%|-  (auto-rewrite mem_addr_calcu) (split-abs-opcode))
%|- QED
     
normal_inc_pc(a): bvec[32] = pc(a) + 4

branch_pc(a) : bvec[32] = normal_inc_pc(a) + sign_extend[16](32)(short_immed_of(instr(a)))

jmp_pc(a) : bvec[32] = ( normal_inc_pc(a) ) ^ (31,28) o long_immed_of(instr(a)) o b00

% --- PC更新
next_pc_3(a:state_A): bvec[32] = 
    IF NOT imem_addr_pred(pc(a)) THEN exception_entry
    ELSE 
     LET dec = decoder(a)
     IN 
     TABLE
      %----------------------------------------------------------+-------------------%%
      | dec`jr?                                                  | rs(a)             ||
      | dec`beq? AND rs_eq_rt(a) OR dec`bne? AND NOT rs_eq_rt(a) | branch_pc(a)      ||
      | dec`jmp?                                                 | jmp_pc(a)         ||
      | exception?(a)                                            | exception_entry   ||
      | ELSE                                                     | normal_inc_pc(a)  || 
      %----------------------------------------------------------+-------------------%%
     ENDTABLE
    ENDIF

step_pc_3: THEOREM next_pc_3 = next_pc_2

%|- step_pc_3 : PROOF
%|- (then (decompose-equality) (expand next_pc_3) (expand next_pc_2)
%|-  (auto-rewrite-theory instruction_decoder)
%|-  (auto-rewrite-theory datapath) (lift-if 1)
%|-  (auto-rewrite-theory specification_trans_3) (split-abs-opcode))
%|- QED


load_state_A : TYPE = { a: valid_pc_state_A | NOT exception?(a) AND decoder(a)`load? }

loadval(a: load_state_A): bvec[32] = LET dec = decoder(a) IN TABLE
        dec`mwidth      
      %----------------+-------------------------------------------------------------------------++ 
      | w8  | IF dec`loadse?  THEN sign_extend[8](32)( read8(dmem(a), alu_out(a)`out ))   
                         ELSE zero_extend[8](32)( read8(dmem(a), alu_out(a)`out ))  ENDIF        ||
      | w16 | IF dec`loadse?  THEN sign_extend[16](32)( read16(dmem(a), alu_out(a)`out )) 
                         ELSE zero_extend[16](32)( read16(dmem(a), alu_out(a)`out )) ENDIF       ||
      | w32 |                   read32(dmem(a), alu_out(a)`out)                                  ||
      %----------------+-------------------------------------------------------------------------++ 
      ENDTABLE


need_wb_state_A: TYPE = { a: valid_pc_state_A | NOT exception?(a) AND decoder(a)`wb? }

upper_imm(a): bvec[32] = zero_extend_lsend[16](32)(short_immed_of(instr(a)))


wb_val(a:need_wb_state_A): bvec[32] =
          LET ins = instr(a)
          IN
           TABLE
            decoder(a)`wbsrc 
           %--------+-----------------------%%
           | aluout | alu_out(a)`out        ||
           | lui    | upper_imm(a)          ||
           | load   | loadval(a)            ||
           | pc4    | normal_inc_pc(a)      ||
           %--------+-----------------------%%
           ENDTABLE

next_rf_3(a:state_A): regfile =
  IF NOT imem_addr_pred(pc(a)) THEN rf(a)
   ELSE 
    IF exception?(a)      THEN rf(a)
    ELSIF decoder(a)`wb?  THEN assign_r(rf(a), dst(a), wb_val(a))
    ELSE rf(a) 
    ENDIF
   ENDIF

step_rf_3: THEOREM next_rf_3 = next_rf_2

%|- step_rf_3 : PROOF
%|- (then (decompose-equality) (expand next_rf_3) (expand next_rf_2)
%|-  (auto-rewrite-theory instruction_decoder)
%|-  (auto-rewrite-theory datapath) (lift-if 1)
%|-  (auto-rewrite-theory specification_trans_3)
%|-  (spread (split-abs-opcode)
%|-   ((then (expand zero_extend) (use "concat_bottom") (expand shamt)
%|-     (assert))
%|-    (then (expand zero_extend) (use concat_bottom) (expand shamt)
%|-     (assert)))))
%|- QED


next_dmem_3(a:state_A):data_memory =
    IF NOT imem_addr_pred(pc(a)) THEN dmem(a) ELSE
    LET 
    src = rt(a),
    wtaddr = alu_out(a)`out,
    dec=decoder(a)
    IN
     IF exception?(a) THEN dmem(a) ELSIF dec`store? THEN 
     TABLE
     dec`mwidth
     %----+-------------------------------------------------------------------%% 
     | w32|                                                                   
     IF NOT dec`atom? OR llflag(a) THEN write32(dmem(a),wtaddr,src) ELSE dmem(a) ENDIF ||
     | w16 |  write16(dmem(a),wtaddr,src^(15,0))                               ||
     | w8 |  write8(dmem(a),wtaddr,src^(7,0))                                 ||
     %----|-------------------------------------------------------------------%%
     ENDTABLE
     ELSE dmem(a) 
     ENDIF
    ENDIF

step_dmem_3: THEOREM next_dmem_3 = next_dmem_2

%|- step_dmem_3 : PROOF
%|- (then (decompose-equality) (expand next_dmem_3) (expand next_dmem_2)
%|-  (auto-rewrite-theory instruction_decoder)
%|-  (auto-rewrite-theory datapath) (lift-if 1)
%|-  (auto-rewrite-theory specification_trans_3) (split-abs-opcode))
%|- QED



next_epc_3(a:state_A):bvec[32] =
   IF NOT imem_addr_pred(pc(a)) THEN pc(a) 
   ELSIF exception?(a)          THEN pc(a)
   ELSE epc(a) 
   ENDIF

step_epc_3: THEOREM next_epc_3 = next_epc_2

%|- step_epc_3 : PROOF
%|- (then (decompose-equality) (expand next_epc_3) (expand next_epc_2)
%|-  (auto-rewrite-theory instruction_decoder)
%|-  (auto-rewrite-theory datapath) (lift-if 1)
%|-  (auto-rewrite-theory specification_trans_3) (split-abs-opcode))
%|- QED


next_llflag_3(a:state_A): bool =
  IF NOT imem_addr_pred(pc(a)) THEN FALSE
  ELSIF exception?(a) THEN FALSE
  ELSE
   LET dec=decoder(a) IN 
   TABLE  
   %-------------------------+-----------%%
   | dec`atom? AND dec`load? | TRUE      ||
   | dec`atom? AND dec`store?| FALSE     ||
   | ELSE                    | llflag(a) ||
   %-------------------------+-----------%%
   ENDTABLE
  ENDIF

step_llflag_3: THEOREM next_llflag_3 = next_llflag_2

%|- step_llflag_3 : PROOF
%|- (then (decompose-equality) (expand next_llflag_3)
%|-  (expand next_llflag_2) (auto-rewrite-theory instruction_decoder)
%|-  (auto-rewrite-theory datapath) (lift-if 1)
%|-  (auto-rewrite-theory specification_trans_3) (split-abs-opcode))
%|- QED


% 单周期参考CPU模型
A_step_3(a: state_A): state_A = (# pc := next_pc_3(a),
                                   rf := next_rf_3(a),
                                   dmem := next_dmem_3(a),
                                   imem := imem(a),
                                   epc  := next_epc_3(a),
                                   llflag := next_llflag_3(a)
                                 #)  


% 单周期满足spec的两个要求
single_cycle: THEOREM A_step = A_step_3  IMPLIES spec_0_goal AND spec_1_goal 

%|- single_cycle : PROOF
%|- (then (flatten) (decompose-equality) (expand A_step_3)
%|-  (auto-rewrite step_pc_3) (auto-rewrite step_dmem_3)
%|-  (auto-rewrite step_epc_3) (auto-rewrite step_llflag_3)
%|-  (auto-rewrite step_rf_3) (auto-rewrite step_pc_2)
%|-  (auto-rewrite step_dmem_2) (auto-rewrite step_epc_2)
%|-  (auto-rewrite step_llflag_2) (auto-rewrite step_rf_2) (assert)
%|-  (use "specification_trans") (expand step_pc_goal)
%|-  (expand step_rf_goal) (expand step_dmem_goal) (expand step_epc_goal)
%|-  (expand step_llflag_goal)
%|-  (spread (split 1)
%|-   ((then (expand spec_0_goal) (expand next_imem) (hide -1) (skosimp)
%|-     (inst?) (assert))
%|-    (then (assert) (hide 1)
%|-     (spread (split)
%|-      ((then (decompose-equality) (inst?) (expand next_pc) (assert))
%|-       (then (decompose-equality) (expand next_rf) (inst?) (assert))
%|-       (then (decompose-equality) (expand next_dmem) (inst?) (assert))
%|-       (then (decompose-equality) (expand next_epc) (inst?) (assert))
%|-       (then (decompose-equality) (expand next_llflag) (inst?)
%|-        (assert))))))))
%|- QED

%--------------------------------------------------------------------------
% Modified specification transition function.
A_step_new(a:state_A,m:nat) : state_A =
	IF m = 0 then a
	ELSE A_step_3(a)  %% m is either 0 or 1. 
	ENDIF



END specification_trans_3
