implementation_state_1_signal: THEORY
BEGIN

IMPORTING implementation_state_1_sync

% 基于流水线状态的基本组合逻辑 前缀 i1s_ 表示本theory名称的简写
q: VAR state_I

i1s_ifu(q): ifu = (# pc := q`a_s`pc, imem := q`a_s`imem #)

% 译码信号


i1s_rf_input_write(q): rf_input_write =
  (# addr := impl_wb_dst(q),
     en   := NOT q`wb_s`bubble AND impl_dec_wb(q)`wb?,
     value := q`wb_s`val #)

% TBD

i1s_dmem_input_write(q): dmem_input_write = LET dec = impl_dec_mem(q) IN
   (# addr := q`mem_s`aluout,
      wen := q`mem_s`state = normal AND dec`store?
            AND ( dec`atom? IMPLIES q`a_s`llflag ),
      value :=  syn1_mux_mem_rt(q),
      mwidth := dec`mwidth  #)


i1s_dmem_input_read(q): dmem_input_read = LET dec = impl_dec_mem(q) IN
   (# addr := q`mem_s`aluout, mwidth := dec`mwidth, se := dec`loadse? #)


i1s_dmem_read_val(q) : bvec[32] = dmem_get_output(i1s_dmem_input_read(q), q`a_s`dmem)

i1s_next_wb_val(q): bvec[32] = 
   LET dec=impl_dec_mem(q), 
       instr=q`mem_s`instr,
       upper_imm=zero_extend_lsend[16](32) (short_immed_of(instr)),
       pc_4=q`mem_s`pc + 4
        IN  TABLE
          dec`wbsrc
          %--------+---------------------%%
          | aluout | q`mem_s`aluout      ||
          | lui    | upper_imm           ||
          | load   | i1s_dmem_read_val(q)||
          | pc4    | pc_4                ||
          %--------+---------------------%%          
         ENDTABLE


i1s_src1(q): bvec[32] = 
   LET dec = impl_dec_ex(q) IN
         TABLE
   dec`sela
   %--------+----------------++
   |  rs    |  syn1_mux_ex_rs(q)  ||
   |  rt    |  syn1_mux_ex_rt(q)  ||
   %--------+----------------++
  ENDTABLE

i1s_src2(q): bvec[32] = 
  LET dec = impl_dec_ex(q),
      instr = q`ex_s`instr,
      shamt_v = zero_extend[5](32)(shamtbv(instr)),
      zext_v =  zero_extend[16](32) (short_immed_of (instr)),
      sext_v =  sign_extend[16](32) (short_immed_of (instr)),
      rt_v = syn1_mux_id_rt(q)  
  IN
 TABLE
  dec`selb
  %--------%----------++
  |  rt    |  rt_v    ||
  |  shamt |  shamt_v ||
  |  zext  |  zext_v  ||
  |  sext  |  sext_v  ||
  %--------%----------++
 ENDTABLE


i1s_next_aluout(q): alu_out =
             alu( i1s_src1(q), i1s_src2(q),impl_dec_ex(q)`aluop )

i1s_ex_exception(q): bool = LET dec = impl_dec_ex(q) IN
           q`ex_s`state = exception OR 
         (  dec`checkov? AND i1s_next_aluout(q)`ov ) OR
         ( q`ex_s`state = normal AND 
           ( dec`load? OR dec`store? ) AND
          NOT dmem_addr_valid?(i1s_next_aluout(q)`out) )


i1s_next_mem_state(q): stage_state = 
        IF i1s_ex_exception(q) THEN exception ELSE q`ex_s`state ENDIF


i1s_branch_addr(q): bvec[32] = q`id_s`pc + 4 + sign_extend[16](32) (short_immed_of (q`id_s`instr))  

i1s_jmp_addr(q): bvec[32] = (q`id_s`pc + 4)^(31,28) o long_immed_of(q`id_s`instr) o b00

i1s_rs_eq_rt(q): bool = syn1_mux_id_rs(q) = syn1_mux_id_rt(q)


i1s_id_branch_taken(q): bool = LET dec = impl_dec_id(q) IN
      ( dec`beq? AND i1s_rs_eq_rt(q) ) OR ( dec`bne? AND NOT i1s_rs_eq_rt(q) )


i1s_next_pc(q): bvec[32]
            = LET dec = impl_dec_id(q) IN
              IF   q`mem_s`state = exception THEN exception_entry 
              ELSIF q`id_s`state = normal AND NOT syn1_stall_issue(q) THEN
                TABLE
             %------------------------+--------------------++
             | i1s_id_branch_taken(q) | i1s_branch_addr(q) ||
             | dec`jmp?               | i1s_jmp_addr(q)    ||
             | dec`jr?                | syn1_mux_id_rs(q)  ||
             | ELSE                   | zero               ||
             %------------------------+--------------------++
                ENDTABLE
              ELSE zero ENDIF

i1s_npc_valid(q): bool = LET dec = impl_dec_id(q) IN 
             q`mem_s`state = exception  OR 
             ( q`id_s`state = normal AND NOT syn1_stall_issue(q) AND
               ( i1s_id_branch_taken(q) OR
                 dec`jmp? OR dec`jr? ) )

i1s_next_ex_state(q): stage_state = LET dec=impl_dec_id(q) IN
             IF dec`invalid?   THEN exception
             ELSIF syn1_stall_issue(q) THEN bubble 
             ELSE q`id_s`state ENDIF


i1s_next_id_state(q): stage_state = 
             IF NOT ifu_get_addr_valid(i1s_ifu(q)) THEN exception
             ELSE normal ENDIF

i1s_get_instr(q): bvec[32] = ifu_get_instr(i1s_ifu(q))


END implementation_state_1_signal
