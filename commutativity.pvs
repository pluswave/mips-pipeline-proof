commutativity: THEORY
BEGIN

IMPORTING abstraction_rewrites
IMPORTING specification_trans
IMPORTING implementation_invariants

q: VAR Reachable_state_I



% 译码信号

VC1_dec: LEMMA impl_dec_wb(I_step(q)) = impl_dec_mem(Complete_till_MEM_WB(q))

VC2_dec: LEMMA impl_dec_mem(I_step(q)) = impl_dec_ex(Complete_till_EX_MEM(q))

VC3_dec: LEMMA impl_dec_ex(I_step(q)) = impl_dec_id(Complete_till_ID_EX(q))

%|- VC*_dec: PROOF
%|- (then (skosimp) (comm-rewrites) (abs-rewrites)  (assert) (expand I_step) (assert))
%|- QED


% WB 阶段

VC1_rf : LEMMA I_step(q)`a_s`rf = Complete_till_MEM_WB(q)`a_s`rf

%|- VC1_rf : PROOF
%|- (then (skosimp) (comm-rewrites) (assert))
%|- QED

VC1_dmem: LEMMA Complete_till_MEM_WB(q)`a_s`dmem = q`a_s`dmem
VC1_pc: LEMMA Complete_till_MEM_WB(q)`a_s`pc = q`a_s`pc
VC1_epc: LEMMA Complete_till_MEM_WB(q)`a_s`epc = q`a_s`epc
VC1_llflag: LEMMA Complete_till_MEM_WB(q)`a_s`llflag = q`a_s`llflag

%|- VC1_* : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (expand Complete_till_MEM_WB) (assert))
%|- QED


% MEM 阶段

VC1_wb_dst: LEMMA impl_wb_dst(I_step(q)) = impl_mem_dst(Complete_till_MEM_WB(q))
VC1_wb_en:  LEMMA impl_rf_wb_en(I_step(q)) = abs_mem_rf_wen(Complete_till_MEM_WB(q))

%|- VC1_wb_*: PROOF
%|- (then (skosimp) (comm-rewrites)  (assert)  (impl-defs) (assert) (expand I_step) (assert) (case-analysis))
%|- QED

VC2_rf:  LEMMA Complete_till_MEM_WB(I_step(q))`a_s`rf = Complete_till_EX_MEM(q)`a_s`rf

%|- VC2_rf : PROOF
%|- (then (skosimp) (comm-rewrites)  (assert)
%|-  (expand Complete_till_MEM_WB) (expand Complete_till_EX_MEM) (assert)
%|-  (expand I_step) (assert))
%|- QED


VC2_dmem: LEMMA I_step(q)`a_s`dmem = Complete_till_EX_MEM(q)`a_s`dmem

%|- VC2_dmem : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (expand Complete_till_EX_MEM)
%|-  (assert) (expand I_step) (assert) (typepred q!1) (assert) (flatten)
%|-  (expand syn1_mem_need_rt_mem)
%|-  (spread (case "q!1`mem_s`state = normal AND impl_dec_mem(q!1)`store?")
%|-   ((then (replace -1) (replace -2) (propax))
%|-    (then (replace 1)
%|-     (spread (rewrite 1 2)
%|-      ((then (expand dmem_update) (propax))
%|-       (then (expand dmem_update) (propax))))))))
%|- QED


VC2_pc_1: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES  I_step(q)`a_s`pc = Complete_till_EX_MEM(q)`a_s`pc
VC2_epc_1: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES I_step(q)`a_s`epc = Complete_till_EX_MEM(q)`a_s`epc
VC2_llflag_1: LEMMA I_step(q)`a_s`llflag = Complete_till_EX_MEM(q)`a_s`llflag

%|- VC2_pc_1 : PROOF
%|- VC2_epc_1 : PROOF
%|- VC2_llflag_1: PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_MEM_WB)
%|-  (expand Complete_till_EX_MEM) (assert) (expand I_step)
%|-  (expand Squash_rest?_till_EX_MEM) (assert) (expand ifu_update)
%|-  (propax))
%|- QED

VC2_pc_2: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES Complete_till_EX_MEM(q)`a_s`pc = q`a_s`pc
VC2_epc_2: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES Complete_till_EX_MEM(q)`a_s`epc = q`a_s`epc

%|- VC2_pc_2 : PROOF
%|- VC2_epc_2 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Squash_rest?_till_EX_MEM)
%|-  (expand Complete_till_EX_MEM) (assert))
%|- QED

% EX阶段

% 引理
VC_src1_1: LEMMA syn1_ex_need_rs_ex(q) IMPLIES  i1s_src1(q) = abs_ex_src1(Complete_till_EX_MEM(q))
VC_src1_2: LEMMA syn1_ex_need_rt_ex(q) IMPLIES  i1s_src1(q) = abs_ex_src1(Complete_till_EX_MEM(q))

%|- VC_src1_2 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand i1s_src1) (expand abs_ex_src1)
%|-  (assert) (expand src1_mux) (assert) (lift-if 1) (copy -1)
%|-  (expand syn1_ex_need_rt_ex (-1) 1) (flatten)
%|-  (spread (split -2)
%|-   ((then (assert) (typepred q!1) (assert))
%|-    (spread (case "syn1_ex_need_rs_ex(q!1)")
%|-     ((then (assert) (typepred q!1) (assert) (flatten) (case-analysis))
%|-      (then (expand impl_dec_ex) (expand syn1_ex_need_rs_ex) (assert)
%|-       (expand impl_dec_ex) (auto-rewrite-theory decoder_props)
%|-       (spread (case-analysis)
%|-        ((then (hide-all-but (-1 -5)) (expand syn1_ex_need_rt_ex)
%|-          (flatten)
%|-          (spread (split -2)
%|-           ((then (assert) (expand decoder) (assert)
%|-             (expand impl_dec_ex) (propax))
%|-            (then (expand decoder) (expand impl_dec_ex) (assert)
%|-             (expand decoder) (assert) (expand decode_sel_b)
%|-             (case-analysis) (expand alu_r?) (propax)))))
%|-         (then (auto-rewrite-theory instruction_decoder)
%|-          (split-abs-opcode))))))))))
%|- QED

%|- VC_src1_1[rs] : PROOF
%|- (then (skosimp) (comm-rewrites) (expand i1s_src1) (expand abs_ex_src1)
%|-  (assert) (expand src1_mux) (assert) (lift-if 1)
%|-  (spread (bddsimp)
%|-   ((then (assert) (typepred q!1) (assert))
%|-    (then (expand syn1_ex_need_#1_ex) (assert)))))
%|- QED

VC_src2_1: LEMMA syn1_ex_need_rt_ex(q) IMPLIES i1s_src2(q) = abs_ex_src2(Complete_till_EX_MEM(q))

%|- VC_src2_1 : PROOF
%|- (then (skosimp) (expand i1s_src2) (expand abs_ex_src2)
%|-  (expand src2_mux) (copy -1) (expand syn1_ex_need_rt_ex (-1) 1)
%|-  (comm-rewrites) (assert) (flatten)
%|-  (spread (split -2)
%|-   ((then (auto-rewrite-theory decoder_props) (assert) (case-analysis)
%|-     (hide-all-but (-1 -4)) (expand impl_dec_ex)
%|-     (auto-rewrite-theory instruction_decoder) (split-abs-opcode))
%|-    (then (case-analysis) (typepred q!1) (assert)))))
%|- QED

VC_src2_2: LEMMA impl_dec_ex(q)`selb /= rt IMPLIES i1s_src2(q) = abs_ex_src2(Complete_till_EX_MEM(q))

%|- VC_src2_2 : PROOF
%|- (then (skosimp) (expand i1s_src2) (expand abs_ex_src2) (comm-rewrites)
%|-  (assert) (expand src2_mux) (case-analysis))
%|- QED


VC_ex_dmem_wen: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES i1s_dmem_wen(I_step(q)) = abs_ex_dmem_wen(Complete_till_EX_MEM(q))

VC_ex_dmem_value: LEMMA NOT Squash_rest?_till_EX_MEM(q) AND abs_ex_dmem_wen(Complete_till_EX_MEM(q)) IMPLIES syn1_mux_mem_rt(I_step(q)) = abs_ex_rt(Complete_till_EX_MEM(q))

%|- VC_ex_dmem_value : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (typepred "I_step(q!1)")
%|-  (expand Reachable?) (flatten) (assert)
%|-  (spread (case "syn1_mem_need_rt_mem(I_step(q!1))")
%|-   ((then (assert) (rewrite -2) (expand abs_mem_rt) (expand abs_ex_rt)
%|-     (assert))
%|-    (then (hide-all-but (-7 1 2)) (expand syn1_mem_need_rt_mem) (assert)
%|-     (expand I_step) (assert) (expand abs_ex_dmem_wen) (assert)
%|-     (spread (case-analysis)
%|-      ((then (expand Squash_rest?_till_EX_MEM) (assert))
%|-       (then (expand Squash_rest?_till_EX_MEM) (assert))))))))
%|- QED


VC3_dmem: LEMMA Complete_till_EX_MEM(I_step(q))`a_s`dmem = Complete_till_ID_EX(q)`a_s`dmem

%|- VC3_dmem : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_EX_MEM)
%|-  (expand Complete_till_ID_EX) (assert)
%|-  (spread (case-analysis)
%|-   ((then (expand Squash_rest?_till_EX_MEM) (expand I_step (1) 2)
%|-     (assert) (expand dmem_update) (propax))
%|-    (spread (case "i1s_dmem_wen(I_step(q!1))")
%|-     ((then (copy -1) (expand i1s_dmem_wen (-1) 1) (assert)
%|-       (replace -1 2) (flatten) (assert) (expand abs_mem_rt)
%|-       (expand abs_ex_rt) (assert) (expand I_step (2) 1) (assert))
%|-      (then (copy 1) (expand i1s_dmem_wen (1) 1) (assert) (replace 1 4)
%|-       (expand dmem_update) (propax)))))))
%|- QED

VC_wb_alu_1: LEMMA q`ex_s`state = normal AND impl_dec_ex(q)`wb? AND impl_dec_ex(q)`wbsrc = aluout IMPLIES i1s_src1(q) = abs_ex_src1(Complete_till_EX_MEM(q)) 
VC_wb_alu_2: LEMMA q`ex_s`state = normal AND impl_dec_ex(q)`wb? AND impl_dec_ex(q)`wbsrc = aluout IMPLIES i1s_src2(q) = abs_ex_src2(Complete_till_EX_MEM(q))

%|- VC_wb_alu_* : PROOF
%|- (then (skosimp) (assert) (use Rewrite_ex_alu_wb_1)
%|-  (use Rewrite_ex_alu_wb_2) (assert) (comm-rewrites) (assert)
%|-  (case-analysis))
%|- QED


VC_ex_rf_wen: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES abs_mem_rf_wen(Complete_till_MEM_WB(I_step(q))) = abs_ex_rf_wen(Complete_till_EX_MEM(q))

%|- VC_ex_rf_wen : PROOF
%|- (then (skosimp) (comm-rewrites) (expand abs_mem_rf_wen)
%|-  (expand abs_ex_rf_wen) (assert) (expand I_step)
%|-  (expand Squash_rest?_till_EX_MEM) (assert) (case-analysis))
%|- QED



VC3_rf: LEMMA Complete_till_EX_MEM(I_step(q))`a_s`rf = Complete_till_ID_EX(q)`a_s`rf

%|- VC3_rf : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_EX_MEM)
%|-  (expand Complete_till_ID_EX) (assert)
%|-  (spread (case-analysis)
%|-   ((then (expand abs_mem_rf_wen) (expand Squash_rest?_till_EX_MEM)
%|-     (assert) (expand I_step) (assert) (expand rf_update) (propax))
%|-    (then (expand abs_ex_rf_wb_val) (assert) (expand I_step (2))
%|-     (assert)
%|-     (spread (case "abs_ex_rf_wen(Complete_till_EX_MEM(q!1))")
%|-      ((then (assert) (expand abs_ex_rf_wen) (assert) (flatten)
%|-        (expand wb_val_mux) (case-analysis))
%|-       (then (expand rf_update) (assert))))))))
%|- QED

VC3_Squash: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES Squash_rest?_till_EX_MEM(I_step(q)) = Squash_rest?_till_ID_EX(q)

%|- VC3_Squash : PROOF
%|- (then (skosimp) (expand Squash_rest?_till_ID_EX) (assert)
%|-  (expand Squash_rest?_ID_EX) (expand Squash_rest?_till_EX_MEM) (assert)
%|-  (comm-rewrites) (assert) (expand I_step) (assert) (case-analysis))
%|- QED

%VC3_pc_1 : LEMMA NOT Squash_rest?_till_EX_MEM(q) AND Squash_rest?_till_ID_EX(q) IMPLIES Complete_till_EX_MEM(I_step(q))`a_s`pc = Complete_till_ID_EX(q)`a_s`pc 
%% ???

VC4_dmem_case_1: LEMMA NOT syn1_stall_issue(q) IMPLIES Complete_till_ID_EX(I_step(q))`a_s`dmem = Complete_till_IF_ID(q)`a_s`dmem





% Level : 3个case * 5 个状态 = 15个case 

comm_rf_case1: CLAIM syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`rf = Complete_till_IF_ID(q)`a_s`rf
comm_dmem_case1: CLAIM syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`dmem = Complete_till_IF_ID(q)`a_s`dmem
comm_pc_case1: CLAIM syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`pc = Complete_till_IF_ID(q)`a_s`pc
comm_epc_case1: CLAIM syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`epc = Complete_till_IF_ID(q)`a_s`epc
comm_llflag_case1: CLAIM syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`llflag = Complete_till_IF_ID(q)`a_s`llflag

comm_rf_case2: CLAIM NOT syn1_stall_issue(q) AND Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`rf = Complete_till_IF_ID(q)`a_s`rf
comm_dmem_case2: CLAIM NOT syn1_stall_issue(q) AND Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`dmem = Complete_till_IF_ID(q)`a_s`dmem
comm_pc_case2: CLAIM NOT syn1_stall_issue(q) AND Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`pc = Complete_till_IF_ID(q)`a_s`pc
comm_epc_case2: CLAIM NOT syn1_stall_issue(q) AND Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`epc = Complete_till_IF_ID(q)`a_s`epc
comm_llflag_case2: CLAIM NOT syn1_stall_issue(q) AND Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`llflag = Complete_till_IF_ID(q)`a_s`llflag

comm_rf_case3: CLAIM NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`rf = A_step(Complete_till_IF_ID(q)`a_s)`rf
comm_dmem_case3: CLAIM NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`dmem = A_step(Complete_till_IF_ID(q)`a_s)`dmem
comm_pc_case3: CLAIM NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`pc = A_step(Complete_till_IF_ID(q)`a_s)`pc
comm_epc_case3: CLAIM NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`epc = A_step(Complete_till_IF_ID(q)`a_s)`epc
comm_llflag_case3: CLAIM NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`llflag = A_step(Complete_till_IF_ID(q)`a_s)`llflag

comm_imem: CLAIM A_step(Complete_till_IF_ID(q)`a_s)`imem = q`a_s`imem

% Level:  3个主要case

stall_prop: CLAIM syn1_stall_issue(q) IMPLIES ABS(I_step(q)) = ABS(q)


squash_prop: CLAIM NOT syn1_stall_issue(q) AND Squash_rest?_till_IF_ID(q) IMPLIES ABS(I_step(q)) = ABS(q)

sync1_prop:  CLAIM NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_IF_ID(q) IMPLIES ABS(I_step(q)) = A_step(ABS(q))

%|- sync1_prop : PROOF
%|- (then (skosimp) (expand ABS) (expand Projection) (assert)
%|-  (auto-rewrite-theory commutativity)
%|-  (auto-rewrite-theory abstraction_rewrites)
%|-  (apply (decompose-equality) (assert))
%|-  (auto-rewrite-theory implementation_trans_1) (assert)
%|-  (expand ifu_update) (expand i1s_ifu) (propax))
%|- QED

sync_func(q): below(2) = IF syn1_stall_issue(q) OR Squash_rest?_till_IF_ID(q) THEN 0 ELSE 1 ENDIF

%|- *_prop : PROOF
%|- (then (skosimp) (expand ABS) (expand Projection) (assert)
%|-  (auto-rewrite-theory commutativity) 
%|- (auto-rewrite-theory abstraction_rewrites) 
%|-  (apply (decompose-equality) (assert)) )
%|- QED

% Level : 终极

commuatativity: THEOREM ABS(I_step(q)) = A_step_new(ABS(q), sync_func(q))

%|- commuatativity : PROOF
%|- (then (skosimp) (auto-rewrite-theory commutativity) (expand A_step_new)
%|-  (expand sync_func) (assert) (lift-if)
%|-  (spread
%|-   (apply (case "syn1_stall_issue(q!1)")
%|-          (then (lift-if) (bddsimp) (assert) (assert)))
%|-   ((assert) (assert))))
%|- QED



END commutativity
