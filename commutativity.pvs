commutativity: THEORY
BEGIN

IMPORTING abstraction_rewrites
IMPORTING specification_trans
IMPORTING implementation_invariants

q: VAR Reachable_state_I



% 译码信号

VC1_dec: LEMMA impl_dec_wb(I_step(q)) = impl_dec_mem(Complete_till_MEM_WB(q))

VC2_dec: LEMMA impl_dec_mem(I_step(q)) = impl_dec_ex(Complete_till_EX_MEM(q))

VC3_dec: LEMMA impl_dec_ex(I_step(q)) = impl_dec_id(Complete_till_ID_EX(q))

%|- VC*_dec: PROOF
%|- (then (skosimp) (comm-rewrites) (abs-rewrites)  (assert) (expand I_step) (assert))
%|- QED


% WB 阶段

VC1_rf : LEMMA I_step(q)`a_s`rf = Complete_till_MEM_WB(q)`a_s`rf

%|- VC1_rf : PROOF
%|- (then (skosimp) (comm-rewrites) (assert))
%|- QED

VC1_dmem: LEMMA Complete_till_MEM_WB(q)`a_s`dmem = q`a_s`dmem
VC1_pc: LEMMA Complete_till_MEM_WB(q)`a_s`pc = q`a_s`pc
VC1_epc: LEMMA Complete_till_MEM_WB(q)`a_s`epc = q`a_s`epc
VC1_llflag: LEMMA Complete_till_MEM_WB(q)`a_s`llflag = q`a_s`llflag

%|- VC1_rf : PROOF
%|- VC1_dmem : PROOF
%|- VC1_pc : PROOF
%|- VC1_epc : PROOF
%|- VC1_llflag : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (expand Complete_till_MEM_WB) (assert))
%|- QED


% MEM 阶段

VC1_wb_dst: LEMMA impl_wb_dst(I_step(q)) = impl_mem_dst(Complete_till_MEM_WB(q))

%|- VC1_wb_dst : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (impl-defs) (assert)
%|-  (expand I_step) (assert) (case-analysis))
%|- QED
VC1_wb_en:  LEMMA impl_rf_wb_en(I_step(q)) = abs_mem_rf_wen(Complete_till_MEM_WB(q))

%|- VC1_wb_en : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (impl-defs) (assert)
%|-  (expand I_step) (assert) (expand abs_mem_rf_wen) (assert)
%|-  (case-analysis))
%|- QED


VC2_rf:  LEMMA Complete_till_MEM_WB(I_step(q))`a_s`rf = Complete_till_EX_MEM(q)`a_s`rf

%|- VC2_rf : PROOF
%|- (then (skosimp) (comm-rewrites)  (assert)
%|-  (expand Complete_till_MEM_WB) (expand Complete_till_EX_MEM) (assert)
%|-  (expand I_step) (assert))
%|- QED


VC2_dmem: LEMMA I_step(q)`a_s`dmem = Complete_till_EX_MEM(q)`a_s`dmem

%|- VC2_dmem : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (expand Complete_till_EX_MEM)
%|-  (assert) (expand I_step) (assert) (typepred q!1) (assert) (flatten)
%|-  (expand syn1_mem_need_rt_mem)
%|-  (spread (case "q!1`mem_s`state = normal AND impl_dec_mem(q!1)`store?")
%|-   ((then (replace -1) (replace -2) (expand i1s_dmem_wen) (propax))
%|-    (then (replace 1) (expand i1s_dmem_wen)
%|-     (spread (rewrite 1 2)
%|-      ((then (expand dmem_update) (propax))
%|-       (then (expand dmem_update) (propax))))))))
%|- QED



VC2_pc_1: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES  I_step(q)`a_s`pc = Complete_till_EX_MEM(q)`a_s`pc
VC2_epc_1: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES I_step(q)`a_s`epc = Complete_till_EX_MEM(q)`a_s`epc
VC2_llflag_1: LEMMA I_step(q)`a_s`llflag = Complete_till_EX_MEM(q)`a_s`llflag
VC2_llflag_2: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES NOT Complete_till_EX_MEM(q)`a_s`llflag
%|- VC2_pc_1 : PROOF
%|- VC2_epc_1 : PROOF
%|- VC2_llflag_1: PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_MEM_WB)
%|-  (expand Complete_till_EX_MEM) (assert) (expand I_step)
%|-  (expand Squash_rest?_till_EX_MEM) (assert) (expand ifu_update)
%|-  (propax))
%|- QED

VC2_pc_2: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES Complete_till_EX_MEM(q)`a_s`pc = q`a_s`pc
VC2_epc_2: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES Complete_till_EX_MEM(q)`a_s`epc = q`a_s`epc

%|- VC2_pc_2 : PROOF
%|- VC2_epc_2 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Squash_rest?_till_EX_MEM)
%|-  (expand Complete_till_EX_MEM) (assert))
%|- QED

% EX阶段

% 引理
VC_src1_1: LEMMA syn1_ex_need_rs_ex(q) IMPLIES  i1s_src1(q) = abs_ex_src1(Complete_till_EX_MEM(q))
VC_src1_2: LEMMA syn1_ex_need_rt_ex(q) IMPLIES  i1s_src1(q) = abs_ex_src1(Complete_till_EX_MEM(q))

%|- VC_src1_2 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand i1s_src1) (expand abs_ex_src1)
%|-  (assert) (expand src1_mux) (assert) (lift-if 1) (copy -1)
%|-  (expand syn1_ex_need_rt_ex (-1) 1) (flatten)
%|-  (spread (split -2)
%|-   ((then (assert) (typepred q!1) (assert))
%|-    (spread (case "syn1_ex_need_rs_ex(q!1)")
%|-     ((then (assert) (typepred q!1) (assert) (flatten) (case-analysis))
%|-      (then (expand impl_dec_ex) (expand syn1_ex_need_rs_ex) (assert)
%|-       (expand impl_dec_ex) (auto-rewrite-theory decoder_props)
%|-       (case-analysis) (hide-all-but (-1 -5))
%|-       (expand syn1_ex_need_rt_ex) (flatten)
%|-       (spread (split -2)
%|-        ((then (assert) (expand decoder) (assert) (expand impl_dec_ex)
%|-          (auto-rewrite-theory instruction_decoder) (split-abs-opcode))
%|-         (then (expand decoder) (expand impl_dec_ex) (assert)
%|-          (expand decoder) (assert) (expand decode_sel_b)
%|-          (case-analysis) (expand alu_r?) (propax))))))))))
%|- QED


%|- VC_src1_1[rs] : PROOF
%|- (then (skosimp) (comm-rewrites) (expand i1s_src1) (expand abs_ex_src1)
%|-  (assert) (expand src1_mux) (assert) (lift-if 1)
%|-  (spread (bddsimp)
%|-   ((then (assert) (typepred q!1) (assert))
%|-    (then (expand syn1_ex_need_#1_ex) (assert)))))
%|- QED

VC_src2_1: LEMMA syn1_ex_need_rt_ex(q) IMPLIES i1s_src2(q) = abs_ex_src2(Complete_till_EX_MEM(q))

%|- VC_src2_1 : PROOF
%|- (then (skosimp) (expand i1s_src2) (expand abs_ex_src2)
%|-  (expand src2_mux) (copy -1) (expand syn1_ex_need_rt_ex (-1) 1)
%|-  (comm-rewrites) (assert) (flatten)
%|-  (spread (split -2)
%|-   ((then (auto-rewrite-theory decoder_props) (assert) (case-analysis)
%|-     (hide-all-but (-1 -4)) (expand impl_dec_ex)
%|-     (auto-rewrite-theory instruction_decoder) (split-abs-opcode))
%|-    (then (case-analysis) (typepred q!1) (assert)))))
%|- QED

VC_src2_2: LEMMA impl_dec_ex(q)`selb /= rt IMPLIES i1s_src2(q) = abs_ex_src2(Complete_till_EX_MEM(q))

%|- VC_src2_2 : PROOF
%|- (then (skosimp) (expand i1s_src2) (expand abs_ex_src2) (comm-rewrites)
%|-  (assert) (expand src2_mux) (case-analysis))
%|- QED


VC_ex_dmem_wen: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES i1s_dmem_wen(I_step(q)) = abs_ex_dmem_wen(Complete_till_EX_MEM(q))

VC_ex_dmem_value: LEMMA NOT Squash_rest?_till_EX_MEM(q) AND abs_ex_dmem_wen(Complete_till_EX_MEM(q)) IMPLIES syn1_mux_mem_rt(I_step(q)) = abs_ex_rt(Complete_till_EX_MEM(q))

%|- VC_ex_dmem_value : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (typepred "I_step(q!1)")
%|-  (expand Reachable?) (flatten) (assert)
%|-  (spread (case "syn1_mem_need_rt_mem(I_step(q!1))")
%|-   ((then (assert) (rewrite -2) (expand abs_mem_rt) (expand abs_ex_rt)
%|-     (assert))
%|-    (then (hide-all-but (-7 1 2)) (expand syn1_mem_need_rt_mem) (assert)
%|-     (expand I_step) (assert) (expand abs_ex_dmem_wen) (assert)
%|-     (spread (case-analysis)
%|-      ((then (expand Squash_rest?_till_EX_MEM) (assert))
%|-       (then (expand Squash_rest?_till_EX_MEM) (assert))))))))
%|- QED


VC3_dmem: LEMMA Complete_till_EX_MEM(I_step(q))`a_s`dmem = Complete_till_ID_EX(q)`a_s`dmem

%|- VC3_dmem : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_EX_MEM)
%|-  (expand Complete_till_ID_EX) (assert)
%|-  (spread (case-analysis)
%|-   ((then (expand Squash_rest?_till_EX_MEM) (expand I_step (1) 2)
%|-     (assert) (expand dmem_update) (propax))
%|-    (spread (case "i1s_dmem_wen(I_step(q!1))")
%|-     ((then (copy -1) (expand i1s_dmem_wen (-1) 1) (assert)
%|-       (replace -1 2) (flatten) (assert) (expand abs_mem_rt)
%|-       (expand abs_ex_rt) (assert) (expand I_step (2) 1) (assert))
%|-      (then (copy 1) (expand i1s_dmem_wen (1) 1) (assert) (replace 1 4)
%|-       (expand dmem_update) (propax)))))))
%|- QED

VC_wb_alu_1: LEMMA q`ex_s`state = normal AND impl_dec_ex(q)`wb? AND impl_dec_ex(q)`wbsrc = aluout IMPLIES i1s_src1(q) = abs_ex_src1(Complete_till_EX_MEM(q)) 
VC_wb_alu_2: LEMMA q`ex_s`state = normal AND impl_dec_ex(q)`wb? AND impl_dec_ex(q)`wbsrc = aluout IMPLIES i1s_src2(q) = abs_ex_src2(Complete_till_EX_MEM(q))

%|- VC_wb_alu_* : PROOF
%|- (then (skosimp) (assert) (use Rewrite_ex_alu_wb_1)
%|-  (use Rewrite_ex_alu_wb_2) (assert) (comm-rewrites) (assert)
%|-  (case-analysis))
%|- QED


VC_ex_rf_wen: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES abs_mem_rf_wen(Complete_till_MEM_WB(I_step(q))) = abs_ex_rf_wen(Complete_till_EX_MEM(q))

%|- VC_ex_rf_wen : PROOF
%|- (then (skosimp) (comm-rewrites) (expand abs_mem_rf_wen)
%|-  (expand abs_ex_rf_wen) (assert) (expand I_step)
%|-  (expand Squash_rest?_till_EX_MEM) (assert) (case-analysis))
%|- QED



VC3_rf: LEMMA Complete_till_EX_MEM(I_step(q))`a_s`rf = Complete_till_ID_EX(q)`a_s`rf

%|- VC3_rf : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_EX_MEM)
%|-  (expand Complete_till_ID_EX) (assert)
%|-  (spread (case-analysis)
%|-   ((then (expand abs_mem_rf_wen) (expand Squash_rest?_till_EX_MEM)
%|-     (assert) (expand I_step) (assert) (expand rf_update) (propax))
%|-    (then (expand abs_ex_rf_wb_val) (assert) (expand I_step (2))
%|-     (assert)
%|-     (spread (case "abs_ex_rf_wen(Complete_till_EX_MEM(q!1))")
%|-      ((then (assert) (expand abs_ex_rf_wen) (assert) (flatten)
%|-        (expand wb_val_mux) (case-analysis))
%|-       (then (expand rf_update) (assert))))))))
%|- QED

%VC3_Squash_1: LEMMA NOT Squash_rest?_till_EX_MEM(q) IMPLIES Squash_rest?_till_EX_MEM(I_step(q)) = Squash_rest?_till_ID_EX(q)
VC3_Squash_1: LEMMA Squash_rest?_till_ID_EX(q) = ( Squash_rest?_till_EX_MEM(q) OR Squash_rest?_till_EX_MEM(I_step(q)) ) 
VC3_Squash_id_bubble:  LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES I_step(q)`id_s`state = bubble
VC3_Squash_ex_bubble:  LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES I_step(q)`ex_s`state = bubble
VC3_Squash_mem_bubble: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES I_step(q)`mem_s`state = bubble
%VC3_Squash_3: LEMMA Squash_rest?_till_EX_MEM(I_step(q)) IMPLIES Squash_rest?_till_ID_EX(q)
%VC3_Squash_4: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES Squash_rest?_till_ID_EX(q)

%|- VC3_Squash_1 : PROOF
%|- (then (skosimp) (expand Squash_rest?_till_ID_EX) (assert)
%|-  (expand Squash_rest?_ID_EX) (expand Squash_rest?_till_EX_MEM) (assert)
%|-  (comm-rewrites) (assert) (expand I_step) (assert) (case-analysis))
%|- QED

%|- VC3_Squash_*_bubble : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Squash_rest?_till_EX_MEM)
%|-  (expand I_step) (assert))
%|- QED

%|- VC3_Squash_3 : PROOF
%|- VC3_Squash_4 : PROOF
%|- (then (skosimp) (comm-rewrites)
%|-  (spread (case "Squash_rest?_till_EX_MEM(q!1)")
%|-   ((then (assert) (expand Squash_rest?_till_ID_EX) (propax)) (assert))))
%|- QED


Rewrite_squash_1: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES NOT Squash_rest?_till_EX_MEM(I_step(q))

%|- Rewrite_squash_1 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Squash_rest?_till_EX_MEM)
%|-  (assert) (expand I_step) (assert))
%|- QED

Rewrite_squash_2: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES NOT Squash_rest?_till_ID_EX(I_step(q))

%|- Rewrite_squash_2 : PROOF
%|- (then (skosimp) (comm-rewrites) (assert)
%|-  (expand Squash_rest?_till_EX_MEM) (assert) (expand I_step) (assert))
%|- QED

Rewrite_squash_3: LEMMA Squash_rest?_till_EX_MEM(q) IMPLIES NOT Squash_rest?_till_IF_ID(I_step(q))

%|- Rewrite_squash_3 : PROOF
%|- (then (skosimp) (comm-rewrites) (assert)
%|-  (expand Squash_rest?_till_IF_ID) (assert) (copy -1)
%|-  (expand Squash_rest?_till_EX_MEM (-1) 1) (assert)
%|-  (spread (case-analysis)
%|-   ((then (expand I_step) (assert)) (then (expand I_step (-3)) (assert))
%|-    (then (expand I_step (-3)) (assert))
%|-    (then (expand I_step (-3)) (assert))
%|-    (then (expand I_step (-3)) (assert))
%|-    (then (expand I_step (-3)) (assert))
%|-    (then (expand I_step (-3)) (assert)))))
%|- QED



VC3_pc_1 : LEMMA NOT Squash_rest?_till_EX_MEM(q) AND Squash_rest?_till_ID_EX(q) IMPLIES Complete_till_EX_MEM(I_step(q))`a_s`pc = Complete_till_ID_EX(q)`a_s`pc 

%|- VC3_pc_1 : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (expand Complete_till_EX_MEM)
%|-  (expand Complete_till_ID_EX) (assert)
%|-  (expand Squash_rest?_till_EX_MEM) (assert) (expand I_step) (assert)
%|-  (case-analysis))
%|- QED


VC3_pc_2: LEMMA NOT Squash_rest?_till_ID_EX(q) IMPLIES Complete_till_ID_EX(q)`a_s`pc = q`a_s`pc

%|- VC3_pc_2 : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (expand Complete_till_ID_EX)
%|-  (assert) (expand Squash_rest?_till_EX_MEM) (assert) (expand I_step)
%|-  (assert) (case-analysis))
%|- QED

VC3_llflag: LEMMA Complete_till_EX_MEM(I_step(q))`a_s`llflag = Complete_till_ID_EX(q)`a_s`llflag

%|- VC3_llflag : PROOF
%|- (then (skosimp) (expand Complete_till_EX_MEM)
%|-  (expand Complete_till_ID_EX) (comm-rewrites) (assert)
%|-  (then (case-analysis) (expand I_step) (expand Squash_rest?_till_EX_MEM) (assert) (case-analysis)))
%|- QED


VC_id_rs: LEMMA abs_ex_rs(Complete_till_EX_MEM(I_step(q))) = abs_id_rs(Complete_till_ID_EX(q))
VC_id_rt: LEMMA abs_ex_rt(Complete_till_EX_MEM(I_step(q))) = abs_id_rt(Complete_till_ID_EX(q))

%|- VC_id_* : PROOF
%|- (then (skosimp) (comm-rewrites) (expand abs_ex_$1) (expand abs_id_$1)
%|-  (assert))
%|- QED

VC_src1_3: LEMMA abs_ex_src1(Complete_till_EX_MEM(I_step(q))) = abs_id_src1(Complete_till_ID_EX(q))
VC_src2_3: LEMMA abs_ex_src2(Complete_till_EX_MEM(I_step(q))) = abs_id_src2(Complete_till_ID_EX(q))

%|- VC_src*_3 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand abs_ex_src$1)
%|-  (expand abs_id_src$1) (expand src$1_mux)  (assert)
%|-  (case-analysis))
%|- QED

VC_dmem_wen_id_ex: LEMMA NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_ex_dmem_wen(Complete_till_EX_MEM(I_step(q))) = abs_id_dmem_wen(Complete_till_ID_EX(q))
VC_rf_wen_id_ex:   LEMMA NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_ex_rf_wen(Complete_till_EX_MEM(I_step(q))) = abs_id_rf_wen(Complete_till_ID_EX(q))
%|- VC_*_wen_id_ex : PROOF
%|- (then (skosimp) (comm-rewrites) (expand abs_ex_$1_wen)
%|-  (expand abs_id_$1_wen) (assert) (flatten)
%|-  (expand Squash_rest?_till_EX_MEM) (assert) (expand I_step) (assert)
%|-  (case-analysis))
%|- QED

VC_rf_wb_val_id_ex:   LEMMA NOT syn1_stall_issue(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_ex_rf_wb_val(Complete_till_EX_MEM(I_step(q))) = abs_id_rf_wb_val(Complete_till_ID_EX(q))

%|- VC_rf_wb_val_id_ex : PROOF
%|- (then (skosimp) (comm-rewrites) (assert) (expand abs_ex_rf_wb_val)
%|-  (expand abs_id_rf_wb_val) (assert))
%|- QED


VC4_dmem_case_1: LEMMA NOT syn1_stall_issue(q) IMPLIES Complete_till_ID_EX(I_step(q))`a_s`dmem = Complete_till_IF_ID(q)`a_s`dmem

%|- VC4_dmem_case_1 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_ID_EX)
%|-  (expand Complete_till_IF_ID) (assert) (case-analysis)
%|-  (expand abs_ex_dmem_wen) (assert) (expand dmem_update) (propax))
%|- QED

VC4_rf_case_1: LEMMA NOT syn1_stall_issue(q) IMPLIES Complete_till_ID_EX(I_step(q))`a_s`rf = Complete_till_IF_ID(q)`a_s`rf

%|- VC4_rf_case_1 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_ID_EX)
%|-  (expand Complete_till_IF_ID) (assert) (case-analysis)
%|-  (expand abs_ex_rf_wen) (assert) (expand rf_update) (propax))
%|- QED

VC4_llflag_case_1: LEMMA NOT syn1_stall_issue(q) IMPLIES Complete_till_ID_EX(I_step(q))`a_s`llflag = Complete_till_IF_ID(q)`a_s`llflag


%|- VC4_llflag_case_1 : PROOF
%|- (then (skosimp) (comm-rewrites) (expand Complete_till_ID_EX)
%|-  (expand Complete_till_IF_ID) (assert) (case-analysis))
%|- QED


VC_stall_bubble: LEMMA syn1_stall_issue(q) IMPLIES I_step(q)`ex_s`state = bubble % 导致VC4_dmem_case_2循环重写？

AUTO_REWRITE- VC_stall_bubble
%|- VC_stall_bubble : PROOF
%|- (then (skosimp) (expand I_step) (comm-rewrites) (assert)
%|-  (case-analysis) (auto-rewrite-theory implementation_state_1_sync)
%|-  (assert) (case-analysis))
%|- QED
VC_stall_normal: LEMMA syn1_stall_issue(q) IMPLIES q`id_s`state = normal

%|- VC_stall_normal : PROOF
%|- (then (skosimp)
%|-  (auto-rewrite-theory implementation_state_1_sync :always? T) (assert)
%|-  (case-analysis))
%|- QED


VC_stall_Squash: LEMMA syn1_stall_issue(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES NOT Squash_rest?_till_ID_EX(I_step(q))

%|- VC_stall_Squash : PROOF
%|- (then (skosimp) (expand Squash_rest?_till_ID_EX (-2)) (assert)
%|-  (comm-rewrites) (assert)
%|-  (spread (case "I_step(q!1)`ex_s`state = bubble ") ((assert) (assert))))
%|- QED


VC4_dmem_case_2: LEMMA syn1_stall_issue(q) IMPLIES Complete_till_ID_EX(I_step(q))`a_s`dmem = Complete_till_ID_EX(q)`a_s`dmem

VC4_rf_case_2: LEMMA syn1_stall_issue(q) IMPLIES Complete_till_ID_EX(I_step(q))`a_s`rf = Complete_till_ID_EX(q)`a_s`rf


%%% comm-rewrites 之前的assert很有用！

%|- VC4_*_case_2 : PROOF
%|- (then (skosimp) (assert) (comm-rewrites) (assert))
%|- QED

% 循环依赖版本
%|- VC4_*_case_2 : PROOF
%|- (then (skosimp) (comm-rewrites)
%|- (assert) (case-analysis))
%|- QED


%|- VC4_*_case_2 : PROOF
%|- (then (skosimp) (comm-rewrites)
%|-  (spread (case "I_step(q!1)`ex_s`state = bubble")
%|-   ((assert)
%|-    (then (hide 2) (expand I_step) (assert) (case-analysis) (hide +)
%|-     (auto-rewrite-theory implementation_state_1_sync :always? T)
%|-     (assert) (case-analysis)))))
%|- QED


VC_id_exception: LEMMA NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) AND abs_id_exception(Complete_till_ID_EX(q)) AND NOT syn1_stall_issue(q) IMPLIES Squash_rest?_till_ID_EX(I_step(q))

%|- VC_id_exception : PROOF
%|- (then (skosimp) (expand Squash_rest?_till_ID_EX (4) 1) (comm-rewrites)
%|-  (assert) (flatten) (expand abs_id_exception) (assert)
%|-  (expand I_step (4 5)) (assert) (expand Squash_rest?_till_EX_MEM)
%|-  (assert) (case-analysis))
%|- QED

VC_id_branch: LEMMA NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) AND abs_id_branch_taken?(Complete_till_ID_EX(q)) AND NOT syn1_stall_issue(q) IMPLIES I_step(q)`id_s`state = bubble

%|- VC_id_branch : PROOF
%|- (then (skosimp) (expand I_step) (comm-rewrites) (assert)
%|-  (expand abs_id_branch_taken?) (assert)
%|-  (expand Squash_rest?_till_EX_MEM (1)) (assert) (flatten) (assert)
%|-  (use Inv_id_rs_id) (use Inv_id_rt_id) (expand Reachable?_id_rs_id)
%|-  (expand Reachable?_id_rt_id) (use Rewrite_syn1_id_1)
%|-  (use Rewrite_syn1_id_2) (assert) (case-analysis))
%|- QED

VC_id_jmp: LEMMA NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) AND abs_id_jmp?(Complete_till_ID_EX(q)) AND NOT syn1_stall_issue(q) IMPLIES I_step(q)`id_s`state = bubble

%|- VC_id_jmp : PROOF
%|- (then (skosimp) (expand I_step) (comm-rewrites) (assert)
%|-  (expand Squash_rest?_till_EX_MEM (1)) (assert) (expand abs_id_jmp?)
%|-  (assert) (case-analysis))
%|- QED


% Level : 3个case * 5 个状态 = 15个case 

VC_stall_id_instr: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) IMPLIES (I_step(q))`id_s`instr = q`id_s`instr
VC_stall_id_dec: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) IMPLIES impl_dec_id(I_step(q)) = impl_dec_id(q)

%|- VC_stall_id_instr: PROOF
%|- VC_stall_id_dec : PROOF
%|- (then (skosimp) (expand impl_dec_id) (expand Squash_rest?_till_EX_MEM)
%|-  (expand I_step) (assert) (comm-rewrites) (assert))
%|- QED
VC_stall_id_dst: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) IMPLIES impl_id_dst(I_step(q)) = impl_id_dst(q)
VC_stall_id_abs_src1: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_id_src1(Complete_till_ID_EX(I_step(q))) = abs_id_src1(Complete_till_ID_EX(q))

%|- VC_stall_id_abs_src* : PROOF
%|- (then (skosimp) (assert) (comm-rewrites) (expand abs_id_src$1) (assert)
%|-  (expand abs_id_rs) (expand abs_id_rt) (assert) (postpone))
%|- QED
VC_stall_id_abs_src2: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_id_src2(Complete_till_ID_EX(I_step(q))) = abs_id_src2(Complete_till_ID_EX(q))

VC_stall_id_rf_wen: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_id_rf_wen(Complete_till_ID_EX(I_step(q))) = abs_id_rf_wen(Complete_till_ID_EX(q))
VC_stall_id_dmem_wen: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_id_dmem_wen(Complete_till_ID_EX(I_step(q))) = abs_id_dmem_wen(Complete_till_ID_EX(q))

%|- VC_stall_id_*_wen : PROOF
%|- (then (skosimp) (assert) (comm-rewrites) (assert)
%|-  (expand abs_id_$1_wen) (assert) (expand I_step (3) 1) (assert)
%|-  (expand Squash_rest?_till_EX_MEM (1) 1) (assert))
%|- QED

VC_stall_id_rf_wb_val: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES abs_id_rf_wb_val(Complete_till_ID_EX(I_step(q))) = abs_id_rf_wb_val(Complete_till_ID_EX(q))

%|- VC_stall_id_rf_wb_val : PROOF
%|- (then (skosimp) (assert) (comm-rewrites) (assert)
%|-  (expand abs_id_rf_wb_val) (assert) (expand I_step (3) 1) (assert))
%|- QED


comm_rf_case0: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`rf = Complete_till_IF_ID(q)`a_s`rf
comm_dmem_case0: CLAIM syn1_stall_issue(q) AND NOT Squash_rest?_till_EX_MEM(q) AND NOT Squash_rest?_till_ID_EX(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`dmem = Complete_till_IF_ID(q)`a_s`dmem

%|- comm_rf_case0 : PROOF
%|- comm_dmem_case0 : PROOF
%|- (then (skosimp) (assert) (comm-rewrites) (expand Complete_till_IF_ID)
%|-  (assert))
%|- QED

comm_rf_case1: CLAIM Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`rf = Complete_till_IF_ID(q)`a_s`rf

%|- comm_rf_case1 : PROOF
%|- comm_dmem_case1: PROOF
%|- (then (skosimp) (comm-rewrites)
%|-  (spread (case "Squash_rest?_till_EX_MEM(q!1)")
%|-   ((assert)
%|-    (spread (case "Squash_rest?_till_ID_EX(q!1)")
%|-     ((then (assert) (replace 1) (assert))
%|-      (then (expand Squash_rest?_till_IF_ID) (replace 1)
%|-       (stop-rewrite VC3_Squash_1) (assert)
%|-       (spread (split -1)
%|-        ((spread (case "syn1_stall_issue(q!1)") ((assert) (assert)))
%|-         (then (assert)
%|-          (spread (case "syn1_stall_issue(q!1)") ((assert) (assert))))
%|-         (spread (case "syn1_stall_issue(q!1)")
%|-          ((assert) (assert)))))))))))
%|- QED


comm_dmem_case1: CLAIM Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`dmem = Complete_till_IF_ID(q)`a_s`dmem
comm_pc_case1: CLAIM Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`pc = Complete_till_IF_ID(q)`a_s`pc
comm_epc_case1: CLAIM Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`epc = Complete_till_IF_ID(q)`a_s`epc
comm_llflag_case1: CLAIM Squash_rest?_till_IF_ID(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`llflag = Complete_till_IF_ID(q)`a_s`llflag

comm_rf_case2: CLAIM NOT Squash_rest?_till_IF_ID(q) AND syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`rf = Complete_till_IF_ID(q)`a_s`rf
comm_dmem_case2: CLAIM NOT Squash_rest?_till_IF_ID(q) AND syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`dmem = Complete_till_IF_ID(q)`a_s`dmem
comm_pc_case2: CLAIM NOT Squash_rest?_till_IF_ID(q) AND syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`pc = Complete_till_IF_ID(q)`a_s`pc
comm_epc_case2: CLAIM NOT Squash_rest?_till_IF_ID(q) AND syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`epc = Complete_till_IF_ID(q)`a_s`epc
comm_llflag_case2: CLAIM NOT Squash_rest?_till_IF_ID(q) AND syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`llflag = Complete_till_IF_ID(q)`a_s`llflag

comm_rf_case3: CLAIM NOT Squash_rest?_till_IF_ID(q) AND NOT syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`rf = A_step(Complete_till_IF_ID(q)`a_s)`rf
comm_dmem_case3: CLAIM NOT Squash_rest?_till_IF_ID(q) AND NOT syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`dmem = A_step(Complete_till_IF_ID(q)`a_s)`dmem
comm_pc_case3: CLAIM NOT Squash_rest?_till_IF_ID(q) AND NOT syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`pc = A_step(Complete_till_IF_ID(q)`a_s)`pc
comm_epc_case3: CLAIM NOT Squash_rest?_till_IF_ID(q) AND NOT syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`epc = A_step(Complete_till_IF_ID(q)`a_s)`epc
comm_llflag_case3: CLAIM NOT Squash_rest?_till_IF_ID(q) AND NOT syn1_stall_issue(q) IMPLIES Complete_till_IF_ID(I_step(q))`a_s`llflag = A_step(Complete_till_IF_ID(q)`a_s)`llflag

comm_imem: CLAIM A_step(Complete_till_IF_ID(q)`a_s)`imem = q`a_s`imem

% Level:  3个主要case

stall_prop: CLAIM Squash_rest?_till_IF_ID(q) IMPLIES ABS(I_step(q)) = ABS(q)


squash_prop: CLAIM NOT Squash_rest?_till_IF_ID(q) AND syn1_stall_issue(q) IMPLIES ABS(I_step(q)) = ABS(q)

sync1_prop:  CLAIM NOT Squash_rest?_till_IF_ID(q) AND NOT syn1_stall_issue(q) IMPLIES ABS(I_step(q)) = A_step(ABS(q))

%|- sync1_prop : PROOF
%|- (then (skosimp) (expand ABS) (expand Projection) (assert)
%|-  (auto-rewrite-theory commutativity)
%|-  (auto-rewrite-theory abstraction_rewrites)
%|-  (apply (decompose-equality) (assert))
%|-  (auto-rewrite-theory implementation_trans_1) (assert)
%|-  (expand ifu_update) (expand i1s_ifu) (propax))
%|- QED

sync_func(q): below(2) = IF syn1_stall_issue(q) OR Squash_rest?_till_IF_ID(q) THEN 0 ELSE 1 ENDIF

%|- *_prop : PROOF
%|- (then (skosimp) (expand ABS) (expand Projection) (assert)
%|-  (auto-rewrite-theory commutativity) 
%|- (auto-rewrite-theory abstraction_rewrites) 
%|-  (apply (decompose-equality) (assert)) )
%|- QED

% Level : 终极

commuatativity: THEOREM ABS(I_step(q)) = A_step_new(ABS(q), sync_func(q))

%|- commuatativity : PROOF
%|- (then (skosimp) (auto-rewrite-theory commutativity) (expand A_step_new)
%|-  (expand sync_func) (assert) (lift-if)
%|-  (spread
%|-   (apply (case "syn1_stall_issue(q!1)")
%|-          (then (lift-if) (bddsimp) (assert) (assert)))
%|-   ((assert) (assert))))
%|- QED



END commutativity
